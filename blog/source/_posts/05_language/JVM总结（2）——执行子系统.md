---
title: JVM总结(2)——执行子系统
categories: 编程语言
tags: 
  - java
  - jvm
date: 2016/6/3 17:37:25
---

JVM 是 Java 编译器和 os 平台之间的虚拟处理器，是利用软件方法对底层硬件平台和操作系统的抽象。Java源文件经编译器编译成字节码文件，通过JVM加载后，JVM将每一条指令翻译成不同平台机器码，并在特定平台上运行。

# 1. 编译

在 Java 中提到“编译”，自然很容易想到 javac 编译器将*.java文件编译成为*.class文件的过程，这里的 javac 编译器称为前端编译器，其他的前端编译器还有诸如 Eclipse JDT 中的增量式编译器 ECJ 等。相对应的还有后端编译器，它在程序运行期间将字节码转变成机器码（现在的 Java 程序在运行时基本都是解释执行加编译执行），如 HotSpot 虚拟机自带的 JIT（Just In Time Compiler）编译器（分 Client 端和 Server 端）。另外，有时候还有可能会碰到静态提前编译器（AOT，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码，如 GCJ、Excelsior JET 等，这类编译器我们应该比较少遇到。

javac 编译简要过程：

* 词法、语法分析。**词法分析**是将源代码的字符流转变为标记（Token）集合。单个字符是程序编写过程中的的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符等都可以成为标记，比如整型标志 int 由三个字符构成，但是它只是一个标记，不可拆分。**语法分析**是根据Token序列来构造抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如 bao、类型、修饰符、运算符等。经过这个步骤后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。
* 填充符号表。完成了语法分析和词法分析之后，下一步就是**填充符号表**的过程。符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析（后面的步骤）中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，党对符号名进行地址分配时，符号表是地址分配的依据。
* **语义分析**。语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是读结构上正确的源程序进行上下文有关性质的审查。语义分析过程分为标注检查和数据及控制流分析两个步骤：（1）标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等。（2）数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。
* 字节码生成。**字节码生成**是 javac 编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 实例构造器()方法和类构造器()方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造函数，而是指我们自己重载的构造函数，如果用户代码中没有提供任何构造函数，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成了）。


# 2. 字节码

JVM执行的是**字节码**，字节码存储在Class类文件中。Class文件是一组以8位字节为基础单元的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符。当遇到需要占用8位以上空间的数据项，则会按照高位在前的方式分割成若干个8位字节进行存储。

Class文件格式采用一种伪结构来存储，这种伪结构中只有2种数据类型：无符号数和表。**无符号数**属于基本数据类型，u1、u2、u4、u8分别代表占用空间为1个、2个、4个、8个字节的无符号数，无符号数用来描述数字、索引引用、数量值、或者按照UTF-8编码构成字符串值。**表**是多个无符号数或其他表作为数据项构成的符合数据类型，所有表都习惯性的已”_info“结尾。

整个Class文件的本质就是一张表，由于没有分割符，Class文件内的所有数据项的顺序、大小、含义都被严格限制：

	名称						类型				数量						含义
	magic 					u4 				1						魔数，确定文件是否为JVM可接受的CLass文件
	minor_version			u2				1						次版本号
	major_version			u2				1						主版本号，JDK版本从45开始，每个大版本加1
	constant_pool_count		u2				1						常量池容量计数
	constant_pool 			cp_info			constant_pool_count-1	常量池，第0项为空，从第1项开始存储
	access_flags			u2				1						访问标识
	this_class				u2				1						类索引
	super_class				u2				1						父索引
	interfaces_count		u2				1						接口计数
	interfaces 				u2				interfaces_count		接口索引
	fields_count			u2				1						字段计数
	fields 					field_info		fields_count			字段表
	methods_count			u2				1						方法计数
	methods 				method_info		methos_count 			方法表
	attributes_count		u2				1						属性计数
	attributes 				attribute_info	attributes_count		属性表

# 3. 类加载机制

Class文件需要加载到JVM中才能被运行和使用。JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是JVM的**类加载机制**。

类的生命过程从加载到JVM内存开始，到从内存卸载为止，经历下面几个阶段：

	加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

**加载**过程是通过类的全限定名获取该类的Class二进制流，转化为方法区中的运行时数据结构，并在堆中生成一个代表该类java.lang.Class对象。**验证**过程确保Class二进制流中包含的数据符合JVM的要求。**准备**过程在方法区中正式为类变量（static修饰的变量）分配内存，并设置类变量初始值。**解析**过程将常量池中的符合引用变为直接引用。
**初始化**过程执行类中变量的赋值操作。

虽然**类加载器**只用于实现类的加载动作，但它的作用却不只是限定在加载阶段。对于任何一个类，都需要加载它的类加载器和这个类本身一同确定其在JVM中的唯一性。从JVM角度看，只存在两种类加载器：**启动类加载器**：使用 C++ 实现（这里仅限于 Hotspot，也就是 JDK1.5 之后默认的虚拟机，有很多其他的虚拟机是用 Java 语言实现的），是虚拟机自身的一部分。**所有其他的类加载器**：这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类 java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。

但从Java开发人员看，类加载器可大致分为3类：

**Bootstrap ClassLoader**（启动类加载器）。跟上面相同，负责加载存放在$JDK_HOME\jre\lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的java.*开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。

**Extension ClassLoader**（扩展类加载器）。该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载$JDK_HOME\jre\lib\ext目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。

**Application ClassLoader**（应用程序类加载器）。该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入**自定义类加载器**，自己编写ClassLoader，读取Class二进制流。

并采用**双亲委派模型**表达类加载器的层次关系和加载顺序，工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

# 4. 执行引擎

执行引擎是


