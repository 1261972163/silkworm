
[SOA和微服务架构的区别？](https://www.zhihu.com/question/37808426)
[微服务实战（一）：微服务架构的优势与不足](http://dockone.io/article/394)
[解析微服务架构(一)：什么是微服务)](https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c/entry/%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84_%E4%B8%80_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1?lang=es)

传统架构面临的挑战

1. 稳定性。很多公司都是从零开始构建自己的系统的，一开始，为了尽快的实现业务，所以系统的架构也相对比较简单。但当业务和用户量开始大规模增长之后，反过来又对系统的性能和稳定性有较高的要求。而传统的单体式（本文均指monolithic）应用把所有的服务都堆到一起，可能会由于一些不重要的服务出问题而影响系统的核心服务。另外，系统对服务的要求也不一样，分开部署可以减小它们之间的相互影响。

2. 可维护性。移动的系统是从2001年开始做的，到现在已经十多年了，这么多年，核心的系统一直是在完善、堆叠。而经过这么多年的维护，系统代码的可维护性非常差，开发人员和技术都已经迭代过几波，系统中代码之间的调用也很多，不是很了解系统的人也不敢轻易动。而由于系统的代码非常多，所以了解系统也不是一件容易的事情。

3. API的版本迭代。单体应用中，一个系统会对应出很多的API，而根据业务的不断迭代，肯定会衍生出很多版本的API，特别是现在很多系统都有不同的端（手机、网站）。API的升级和维护都需要有相应版本的管理，而单体式的应用在这一块，有明显的短板。另外，API的发布周期也会很慢，因为版本的发布涉及到整体的协调和测试。

4. 持续集成。单体式的应用由于比较大，应用内部的依赖非常多，涉及的业务逻辑也比较复杂。在CI流程中，如果没有很好的约定的话，失败的次数也会比较多。另外，由于代码基比较大，所以构建的时间也会非常长，如果构建错误，排查问题也会比较困难。


参考文献

1. [先把平台做扎实，再来微服务吧](http://www.infoq.com/cn/articles/how-to-understand-microservice-architecture)
2. [组件化、模块化、集中式、分布式、服务化、面向服务的架构、微服务架构](http://www.hollischuang.com/archives/1628)
3. [技术大牛讲述微架构与容器化的持续交付实践](http://www.dockerinfo.net/3105.html)
4. [谈服务治理与组织架构的关系](http://www.infoq.com/cn/articles/service-management-and-organizational-structure)
5. [服务治理过程演进](http://javatar.iteye.com/blog/1345073)
6. [深入学习微框架：Spring Boot](http://www.infoq.com/cn/articles/microframeworks1-spring-boot/)
7. [微服务监控中不可不知的五项原则](http://www.dockerinfo.net/3304.html)
8. [从架构到部署-微服务架构实战](http://www.dockerinfo.net/773.html)
9. [微服务容器化的挑战和解决之道](http://www.dockerinfo.net/621.html)

# 1. 什么是微服务

* 一个大型复杂软件应用由一个或多个微服务组成。
* 各个微服务可被独立部署，松耦合。
* 将相关联的业务逻辑及数据放在一起形成独立的边界。
* 每个微服务仅关注于完成一件任务并很好地完成该任务。
* 将组件间通讯的相关业务逻辑/智能放在组件端点侧而非放在通讯组件中，通讯机制或组件应该尽量简单及松耦合。RESTful HTTP协议和仅提供消息路由功能的轻量级异步机制是微服务架构中最常用的通讯机制。


* 组件化。将组件定义为可被独立替换和升级的软件单元。
* 业务单元。采取以业务能力为出发点组织服务的策略，将相关联的业务逻辑及数据放在一起形成独立的边界。
* 产品模式。用产品的思想去负责微服务的生命周期。
* 智能端点与管道扁平化。微服务架构主张将组件间通讯的相关业务逻辑/智能放在组件端点侧而非放在通讯组件中，通讯机制或组件应该尽量简单及松耦合。RESTful HTTP协议和仅提供消息路由功能的轻量级异步机制是微服务架构中最常用的通讯机制。
* 去中心化治理。鼓励使用合适的工具完成各自的任务，倾向于寻找其他开发者已成功验证解决类似问题的技术。
* 去中心化数据管理。倡导采用多样性持久化的方法，让每个微服务管理其自有数据库，并允许不同微服务采用不同的数据持久化技术。
* 基础设施自动化。云化及自动化部署等技术极大地降低了微服务构建、部署和运维的难度，通过应用持续集成和持续交付等方法有助于达到加速推出市场的目的。
* 故障处理。微服务架构所带来的一个后果是必须考虑每个服务的失败容错机制。因此，微服务非常重视建立架构及业务相关指标的实时监控和日志机制。
* 演进式的设计。微服务应用更注重快速更新，因此系统的计会随时间不断变化及演进。微服务的设计受业务功能的生命周期等因素影响。

应用场景：

1. 记录型系统(System of Record)将从微服务方法中获益最多。例如可将大型应用按相对独立的业务功能分解成若干个微服务实现。
2. 交互型系统(System of Engagement)也将受益于微服务方法，例如渠道应用可以应用“后端服务前端”的模式实现。
3. 分析型系统(System of Insight)则可能对微服务受益不多。其他架构模式如管道及过滤模式可能更适用于分析型系统。

微服务架构的缺点：

微服务的一些想法在实践上是好的，但当整体实现时也会呈现出其复杂性。

1. 运维开销及成本增加：整体应用可能只需部署至一小片应用服务区集群，而微服务架构可能变成需要构建/测试/部署/运行数十个独立的服务，并可能需要支持多种语言和环境。这导致一个整体式系统如果由20个微服务组成，可能需要40~60个进程。
2. 必须有坚实的DevOps开发运维一体化技能：开发人员需要熟知运维与投产环境，开发人员也需要掌握必要的数据存储技术如NoSQL，具有较强DevOps技能的人员比较稀缺，会带来招聘人才方面的挑战。
3. 隐式接口及接口匹配问题：把系统分为多个协作组件后会产生新的接口，这意味着简单的交叉变化可能需要改变许多组件，并需协调一起发布。在实际环境中，一个新品发布可能被迫同时发布大量服务，由于集成点的大量增加，微服务架构会有更高的发布风险。
4. 代码重复：某些底层功能需要被多个服务所用，为了避免将“同步耦合引入到系统中”，有时需要向不同服务添加一些代码，这就会导致代码重复。
5. 分布式系统的复杂性：作为一种分布式系统，微服务引入了复杂性和其他若干问题，例如网络延迟、容错性、消息序列化、不可靠的网络、异步机制、版本化、差异化的工作负载等，开发人员需要考虑以上的分布式系统问题。
6. 异步机制：微服务往往使用异步编程、消息与并行机制，如果应用存在跨微服务的事务性处理，其实现机制会变得复杂化。
7. 可测性的挑战：在动态环境下服务间的交互会产生非常微妙的行为，难以可视化及全面测试。经典微服务往往不太重视测试，更多的是通过监控发现生产环境的异常，进而快速回滚或采取其他必要的行动。但对于特别在意风险规避监管或投产环境错误会产生显著影响的场景下需要特别注意。
 
关于微服务架构的取舍

* 在合适的项目，合适的团队，采用微服务架构收益会大于成本。
* 微服务架构有很多吸引人的地方，但在拥抱微服务之前，也需要认清它所带来的挑战。
* 需要避免为了“微服务”而“微服务”。
* 微服务架构引入策略 – 对传统企业而言，开始时可以考虑引入部分合适的微服务架构原则对已有系统进行改造或新建微服务应用，逐步探索及积累微服务架构经验，而非全盘实施微服务架构。