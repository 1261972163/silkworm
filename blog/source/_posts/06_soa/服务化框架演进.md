---
title: 服务化框架演进
categories: 服务化
tags: 
	- soa
	- 服务化
date: 2016/6/3 17:37:25
---

当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。这种情况下，服务调用通常发生在同一机器同一程序语言环境下，比如要调用程序模块M中的A方法，只需要向M的A方法发送请求，传入A方法需要的参数P，方法A执行完毕后，返回处理结果R。

当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，需要将应用纵向拆成互不相干的几个应用，应用之间可以通过网络通信传达语义，成为**垂直应用**。这是**分而治之**的思想，实现了组件化和模块化。**组件化**就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合。**模块化**的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。将一个大的系统模块化之后，每个模块都可以被高度复用。

当应用越来越多，应用之间直连关系变得错综复杂，这时就需要重新考虑整个系统的结构，将核心业务抽取出来，作为独立的服务，进行系统SOA。**SOA**（面向服务的架构）是一种架构风格，一种IT系统咨询和建设的方法论。SOA的核心包含两方面内容：在**服务的定义**上，要求服务满足离散、松耦合、可复用、自治、无状态等基本特征。比如：一个CRM系统中，在门户网站返回2017年第一季度的所有客户信息，这个功能很基础不牵扯其他功能（离散、自治、无状态），要统计第二季度的所有客户信息都不行（不完全可复用），可以将这个功能改回接收任意的起始和截止时间，而不是限定于某个季度（可复用），让它接收任意应用的访问，而不仅仅是门户，让具体的某个应用作为参数输入，系统不能只为了门户硬编码（松耦合）。另一方面是**服务治理**，可以对服务进行灵活的组装和编排，满足流程整合和业务变化的需要。

**ESB**（企业服务总线）是SOA技术架构实施的基本部件，最基本功能是实现点对点集成到总线式集成的转换，在这个过程中实现了消息协议的转换和适配、数据传输、数据转换和映射等基本功能。比如调用方用http协议，提供方用rmi协议，转发就可以转换协议，对双方都透明。

应用如果要像调用本地方法一样调用其他模块的方法，这就需要RPC了。比如现在有两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，A需要通过网络来向B表达调用的语义和传达调用的数据，B接收并处理完数据后返回给A，这过程就是**RPC**，调用流程大致为：

	1. A上的服务消费方以本地调用方式调用服务接口；
	2. A上的ClientStub接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体；
	3. A上的ClientStub找到服务地址，并将消息序列化后发送到B上的服务提供方；
	4. B上的ServerStub收到消息后进行反序列化，获取消息内容；
	5. B上的ServerStub根据消息内容调用本地的服务；
	6. B上的本地服务执行并将结果返回给B上的ServerStub；
	7. B上的ServerStub将结果打包成消息并发送至A上的服务消费方；
	8. A上的ClientStub接收到消息，并进行反序列化，获取消息内容；
	9. A上的服务消费方得到最终结果。

RPC的目标就将2~8步骤封装起来，让用户对这些细节透明。但RPC的问题是：（1）兼容性问题。如果各个应用所使用的编程语言不相同，RPC就会出现异构系统兼容性问题；（2）安全问题，防火墙和代理服务器通常会阻止此类RPC流量。

**WebService**服务端和客户端同样通过RPC实现一致性访问。针对兼容性问题，使用**SOAP**（Simple Object Access Protocol，简单对象访问协议）描述对象的结构和数据，实质就是一种通信契约，让不同网络不同平台不同语言的应用程序都能识别。使用**WSDL**（Web Services Description Language，接口描述语言）描述接口：
	
	<types>        定义数据类型，描述了接口所有方法的参数类型和返回值类型，具有平台无关性
	<messages>     描述输入参数和输出参数，参数类型使用types标签中的数据类型来描述
	<portType>     描述接口方法操作，操作参数使用message标签中的参数来描述
	<binding>      描述使用的通信协议，操作部分匹配portType标签中的操作
	<service>      定义每个binding的地址

针对安全问题，WebService定义**SOAP使用HTTP传送XML**，尽管HTTP不是有效率的通讯协议，而且XML还需要额外的文件解析（parse），两者使得交易的速度大大低于其它方案。但是XML 是一个开放、健全、有语义的讯息机制，而 HTTP是一个广泛又能避免许多关于防火墙的问题，从而使SOAP得到了广泛的应用。但是如果效率对你来说很重要，那么你应该多考虑其它的方式，而不要用SOAP。

下面通过Jdk1.6自带的JAX-WS来看一下一个完整的WebService调用过程：

	1. Server提供和实现A接口，并生成Endpoint，将接口A作为WebService发布。
	2. Client从Server读取WebService的WSDL，并生成接口A的代理Proxy，负责与Server进行 Request 和 Response。
	3. Client以本地调用方式调用服务接口；
	4. Client的代理WSServiceDelegate接收到调用后，将方法、参数等封装成SOAP消息，并通过HTTP协议进行传输。
	5. Server的WSHttpHandler接收到HTTP消息后，利用HttpAdapter从HTTP消息中读出Packet（包含SOAP消息）。
	6. Server的SEIInvokerTube利用DatabindingImpl将Packet解析为JavaCallInfo。
	7. Server的SEIInvokerTube从JavaCallInfo读取方法名，利用方法名反射出方法，调用本地服务方法，并将结果放入JavaCallInfo。
	8. Server的SEIInvokerTube利用DatabindingImpl将JavaCallInfo封装成Packet。
	9. Server的HttpAdapter将Packet封装成HTTP消息，发送到Client。
	10. Client的SEIStub得到HTTP消息，从HTTP消息中读出Packet。
	11. Client的SEIStub利用DatabindingImpl将Packet解析为JavaCallInfo。
	10. Client的SEIStub从JavaCallInfo中读取结果

WebService只是SOA的一种实现，SOA还有很多种实现。[**CXF**](http://cxf.apache.org/)应该说是SOA的集大成者，为我们提供了一个实施SOA的具体实现，支持多种服务化风格（jax-ws、jax-rs等），支持多种通信协议（如SOAP、XML/HTTP、RESTful HTTP和CORBA等）和传输协议（ HTTP、JMS和JBI等）。服务注册到总线，在总线上执行流程引擎，服务路由，做服务编排，比如A和B两个服务经常一起调，就可以编排成服务C，而不用再单独启一个服务去做。还有，安全，流控，做起来也更方便。

服务化使搭建分布式系统成为了可能。**分布式**就是一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样。分布式意味着可以采用更多的普通计算机（相对于昂贵的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。当服务越来越多时，

（1）服务URL配置管理变得非常困难，如何管理URL?

CXF需要服务端和客户端通过url暴露和引用远程服务，通过配置服务的URL地址进行调用。**Dubbo**引入**服务注册中心**，对服务进行动态注册和发现，是服务位置透明。服务消费方Consumer通过注册中心获取服务提供方Provider的地址列表。

(2) 当相同服务由多个提供方同时提供时，消费方如何选择？F5硬件负载均衡器的单点压力也越来越大，如何负载均衡？

* 容错。集群是从容错的维度来完成选择合适的服务提供方，包括Failover、Failfast、Failsafe、Failback、Forking、Broadcast等机制。
* 自定义。路由规则和配置是一种定制化的选择，可以在更细颗粒度的层面做选择，包括分组、机器、方法等。
* 降级。当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。服务降级方法主要包括：直接拒绝、失败拒绝等。
* 性能。负载均衡将请求均衡到所选的机器上，主要策略有：Random、RoundRobin、LeastActive、ConsistentHash。

(3) 服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。

自动展现应用间的依赖关系图，以帮助架构师理清理关系。

(4) 服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？

为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。

在[**康威定律**](https://yq.aliyun.com/articles/8611?spm=5176.100239.blogcont2764.13.tRTWQf)的理论基础上出现了**微服务架构**，是比SOA更彻底的服务拆分，同时去中心ESB，实现敏捷开发和部署。官方对微服务的定义是这样的：

> The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are **built around business capabilities** and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services , which may be written in different programming languages and use different data storage technologies.
>      -- James Lewis and Martin Fowler

翻译过来是这样的：

	1. 一系列独立小服务共同组成系统；
	2. 围绕业务能力独立构建服务；
	3. 每个服务单独部署，运行在自己的进程里；
	4. 服务之间轻量化通信，通常是HTTP API访问；
	5. 最低限度的集中管理这些服务，这些服务可以使由不同的编程语言编写，可以使用不同的数据存储技术。

个人理解是：微服务架构把所有的“思考”逻辑包括路由、消息解析等放在服务内部（Smart endpoints），去掉一个集中化的ESB，实现服务间轻通信（dumb pipes）。听上去好像很不错，[这里](http://microservices.io/patterns/microservices.html?spm=5176.100239.blogcont2764.19.tRTWQf)有一个微服务架构图很好的总结了具体实施时需要考虑的问题。

![](http://microservices.io/i/PatternsRelatedToMicroservices.jpg)

服务化的框架可以解决上面大部分问题，剩下2个问题需要考虑：

如何围绕业务划分服务？

如何部署？






![](../resources/服务化演进/msa.png)


# 参考文献

1. [Dubbo用户指南](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-Zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83)