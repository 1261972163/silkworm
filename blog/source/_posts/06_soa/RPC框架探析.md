---
title: RPC框架探析
categories: 服务化
tags: 
	- soa
	- rpc
date: 2015/11/3 17:37:25
---

对于RPC框架，首先需要了解什么叫RPC，为什么要RPC。**RPC**是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。

RPC调用流程大致为：

1. A上的服务消费方以本地调用方式调用服务接口；
2. A上的ClientStub接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体；
3. A上的ClientStub找到服务地址，并将消息序列化后发送到B上的服务提供方；
4. B上的ServerStub收到消息后进行反序列化，获取消息内容；
5. B上的ServerStub根据消息内容调用本地的服务；
6. B上的本地服务执行并将结果返回给B上的ServerStub；
7. B上的ServerStub将结果打包成消息并发送至A上的服务消费方；
8. A上的ClientStub接收到消息，并进行反序列化，获取消息内容；
9. A上的服务消费方得到最终结果。

RPC的目标就将2~8步骤封装起来，让用户对这些细节透明。

# 1. 透明化远程服务调用

透明是对通信的封装，让用户像本地调用方式一样调用远程服务。通常使用代理技术来实现。Java代理有两种方式：（1）JDK动态代理，或者CGLib；（2）字节码生成。

尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。

我们实现了ClientProxy代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从ClientProxy获得服务提供方的接口，当执行接口方法时就会调用invoke方法。

# 2. RPC协议

invoke里需要封装通信细节，而通信的第一步就是要确定客户端和服务端相互通信的消息结构，即RPC协议。

客户端的请求消息结构（见Request.java）一般需要包括以下内容：

|消息内容|描述|
|:--|:--|
|className|接口名|
|methodName|方法名|
|parameterTypes|参数类型|
|parameters|参数值|
|requestId|请求的唯一id|

同理，服务端返回的消息结构（见Response.java）一般包括以下内容：

|消息内容|描述|
|:--|:--|
|result|执行结果|
|error|执行时发生的错误|
|requestId|请求的唯一id|

# 3. 寻址

通信时，客户端需要知道如何提供服务的主机以及端口。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。

现如今zookeeper被广泛用于实现服务自动注册与发现功能。ZooKeeper充当一个服务注册中心。多个服务提供者形成一个分布式集群，服务提供者通过服务注册的方式将其服务地址（主要包括主机名和端口号）注册到服务注册表；服务消费者监听服务注册表，自动发现（机器的增添、剔除对调用方透明，调用者不再需要写死服务提供方地址）当前可用服务。让服务消费者通过服务注册表获取具体的服务访问地址（ip+端口）去访问具体的服务提供者。

# 4. 消息序列化/反序列化

消息传输需要通过底层的网络协议如TCP传递，由于网络协议是基于二进制的，内存中数据需要转换成二进制的形式，也就是序列化（见RpcEncoder.java）。同理，将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程就是反序列化（见RpcDecoder.java）。

现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从RPC的角度上看，主要看三点：

* 通用性，比如是否能支持Map等复杂的数据结构；
* 性能，包括时间复杂度和空间复杂度，由于RPC框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；
* 可扩展性，对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。

目前互联网公司广泛使用Protobuf、Thrift、Avro等成熟的序列化解决方案来搭建RPC框架，这些都是久经考验的解决方案。

# 5. 通信

消息数据结构被序列化为二进制串后，下一步就要进行网络通信了。目前有两种常用IO通信模型：（1）BIO；（2）NIO。一般RPC框架需要支持这两种IO模型。

使用java nio方式自研，这种方式较为复杂，而且很有可能出现隐藏bug，但也见过一些互联网公司使用这种方式；基于mina，mina在早几年比较火热，不过这些年版本更新缓慢；基于netty，现在很多RPC框架都直接基于netty这一IO通信框架，省力又省心，比如阿里巴巴的HSF、dubbo，Twitter的finagle等。

# 6. 服务执行

服务提供方接收到服务消费方传过来的消息，反序列化后得到需要调用的类名、方法名、参数类型、参数等信息，利用这些信息通过反射的方式进行方式执行。

为了避免使用 Java 反射带来的性能问题，我们可以使用 CGLib 提供的反射 API，如ServerHandler.java用到的FastClass与FastMethod。


# 参考文献

1. [轻量级分布式 RPC 框架](http://www.importnew.com/20327.html)
2. [RPC原理及RPC实例分析](http://www.importnew.com/22003.html)
3. [谁能用通俗的语言解释一下什么是 RPC 框架？](https://www.zhihu.com/question/25536695)
4. [远程通信的几种选择（RPC，Webservice，RMI，JMS的区别）](http://blog.csdn.net/shan9liang/article/details/8995023)