《程序员修炼之道》笔记
=======================

## 第一章 注重实效的哲学

### 1 我的源码让猫给吃了

不害怕承认自己的无知和错误，但需要提前制定可能的解决方案作为应急计划，而不是盲目去请教别人或者找借口。

### 2 软件的熵

及时解决问题，不要让问题遗留下来成为无序代码的一部分。个人观点，这样是不是会让人钻牛角尖。

### 3 石头汤与煮青蛙

要想让事情顺利进行，首先得拿出优秀的初始版本，这样才能调动他人的积极性，吸引他们进行协作，进一步完善系统。

主动的去发现问题并解决问题，而不只是解决手头的工作，才能让系统走的更远。

### 4 足够好的软件

足够好不是说不整洁或代码糟糕，而是系统必须满足用户的需求，这样才能取得成功。

让用户参与进来，通过他们的使用反馈需求，驱动开发。

不要过度修饰和追求完美的代码，否则，就会迷失在代码的修改中。个人观点，这个度很难把握。


### 5 你的知识资产

保持学习，多元化学习，有重点的突破。

一些建议：一年学一门语言、每季度读一本技术书籍、阅读非技术书籍、多尝试不同的环境（系统、IDE等）、参加组织或讲座、查阅资料、分享成果。

为自己争取学习的空间和时间。

批判性思考。

### 6 交流

规划自己要说的内容。

了解听众的需求、兴趣和能力。

选择合适的时机进行交流。

尊重他人。

## 第二章 注重实效的途径

### 7 重复的危害

？

### 8 正交性

？

### 9 可撤销性

我们不可能一开始就做出最正确合适的决定，而构建灵活的架构就可以帮助系统应对复杂的应用变化。

### 10 曳光弹

测试驱动开发，逐步完善功能。

### 11 原型与便笺

整个系统的建模，考虑系统如何结合成一个整体，推迟考虑细节。

### 12 领域语言

### 13 估算

学习估算，对事物的数量级要有直觉，从而确定可行性，避免发生意外。

基本的估算诀窍：去问已经做过这件事情的人。

估算需要考虑的问题：

* 精确度，即估算到多少才足够准确；
* 把握问题域的范围，即得出估算结果的前提；
* 建立系统模型，即对问题建立粗略、就绪的思维模型骨架；
* 模型分解为组件；
* 确定组件参数的影响；
* 计算估算值；
* 追踪自己的估算能力，分析得失原因；
* 估算项目进度。

不要过快下结论，多说“我等会儿回答你”。

## 第三章 基本工具

### 14 纯文本的威力

纯文本（并非无结构）实现自描述的、不依赖于创建它的应用的数据流，保证了通用性。

### 15 shell游戏

习惯命令提示下工作，通常效率更高。

### 16 强力编辑

选择一种编辑器（能在所有平台上使用），彻底了解它，并将其用于所有的编辑任务。

推荐：Emacs、vi、CRiSP、Brief等。

### 17 源码控制

始终使用源码控制，即使只有自己开发。

### 18 调试

调试就是解决问题，应该专注于修正问题，而不是发出指责。

调试时要让自己放松下来，不要恐惧。

测试策略：

* 使数据可视化；
* 跟踪；
* 向虚拟人解释；
* 首先从自身代码找问题；
* 不要假定代码正确，要证明。

### 19 文本操作

精通一种文本操作语言，也就是脚本语言。

### 20 代码生成器

## 第四章 注重实效的偏执

完美的软件不存在。

### 21 按合约设计

？

### 22 死程序不说谎

让程序在出问题的时候崩溃，防止其产生更大的破坏。

### 23 断言式编程

通过断言来证明自己的结论。

### 24 何时使用异常

对异常问题使用异常。

### 25 怎样配平资源

？

## 第五章 弯曲，或折断

### 26 解耦与得墨忒耳法则

？

### 27 元程序设计

让系统变的高度动态可配置，而不是一个集成的整体。这样可以实现声明式思考，解除耦合，带来更灵活、可适应性更好的程序。

具体做法：

* 通过元数据配置和驱动应用。
* 将抽象放进代码，细节放进元数据。

### 28 时间耦合

允许并发，解除任何时间或次序上的依赖。

分析工作流，以改善并发性。

设计程序时，多考虑并发，预防并发产生的问题。


### 29 它只是视图

通过事件把某个对象的状态变化通知给可能感兴趣的其他对象。

发布/订阅

MVC框架

### 30 黑板

## 第6章 当你编码时

### 31 靠巧合编程

避免靠巧合编程，要深思熟虑地编程：

* 时刻意识到自己在做什么。
* 不要盲目地编程。不要想当然，不要嘚瑟，时刻警惕。
* 按照计划行事。
* 依靠可靠的事物，时刻假设最坏情况。
* 为假设建立文档。
* 不只是测试代码，还有测试假设。
* 为工作划分优先级。把时间花在重要的方面。
* 不做历史的奴隶。不要让已有的代码支配将来的代码，如果不适用，所有的代码都可以替换。

### 32 算法速率

分析算法的能力。

### 33 重构

当已经确定代码不再合适时，立刻考虑重构，不要对改动犹豫不决。

判定的依据：

* 重复。
* 非正交的设计。
* 过时的知识。
* 性能。

重构是一项需要慎重、深思熟虑、小心进行的活动。

重构建议：

* 不在重构的同时添加新的功能；
* 重构前，确保已经拥有良好的测试用例，并经常测试；
* 采取短信、深思熟虑的步骤。

### 34 易于测试的代码

确立测试合约，创建单元测试

### 35 邪恶的向导

不要使用不理解的向导代码（自动生成框架）。

## 第七章

项目启动太快不好，等的太久可能更糟。

### 36 需求之坑

没有什么功能需要增加，不是完美；完美，是没有功能需要去掉。

不要搜集需求，去挖掘需求。

和用户一起工作，或者站在用户的角度去思考，去发掘需求。

好的需求文档会保持抽象，能准确表达需求就可以。

### 37 解开不可能解开的谜题

跳出局部的约束，去寻找真正的约束，站在更高的高度去思考，找到解决方法。

### 38 等你准备好

当面对一个任务时，如果反复感觉到疑虑，或者体验到某种勉强，要注意它。

如何确定“拖延”和“准备就绪”？构建原型，进行“概念验证”。

### 39 规范陷阱

适当规范即可，对有些事情，“做”胜过“描述”。

### 40 圆圈与箭头

不要变成方法学的奴隶，学习新技术和方法是好事情，但如果不能将新技术和方法放进自己的开发实践和能力的语境中，就会陷入盲目区，效率和效果也不会好。

## 第八章 注重实效的项目

### 41 注重实效的团队

### 42 无处不在的自动化

自动化以保证团队中的一致性和可重复性。需要使用一致的项目管理工具。

### 43 无情的测试

早测试，常测试，自动测试。

测试什么：

* 单元测试
* 集成测试
* 验证和校验
* 资源耗尽、错误及恢复
* 性能测试
* 可用性测试

怎样测试：

* 回归测试
* 测试数据。现实数据和合成数据。
* 演练GUI系统
* 彻底测试

### 44 全都是写

编码的艺术

### 45 极大的期望

项目的成功是由它满足用户期望的程度来衡量的，要温和地超出用户的期望。

### 46 傲慢与偏见

不逃避责任，乐于接受挑战，让自己的代码值得自己为之自豪。








